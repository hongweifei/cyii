/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["EUV"] = factory();
	else
		root["EUV"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/euv.js":
/*!********************!*\
  !*** ./src/euv.js ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EUV: () => (/* binding */ EUV)\n/* harmony export */ });\n\r\nclass EUVElement {\r\n    /**\r\n     * @param { HTMLElement } element\r\n     */\r\n    constructor(element) {\r\n        if (!element) {\r\n            throw new Error(\"element is null\");\r\n        }\r\n        this.domElement = element;\r\n        this.tagName = element.tagName;\r\n        this.attributes = new Map();\r\n        this.tempDisplay = element.style.display;\r\n        this.eventMethodMapping = new Map();\r\n        this.eventInit = false;\r\n        for (const a of element.attributes) {\r\n            if (a.name[0] === '@') {\r\n                this.eventMethodMapping.set(a.name.substring(1), a.value);\r\n                continue;\r\n            }\r\n            this.attributes.set(a.name, a.value);\r\n        }\r\n        this.innerHTML = element.innerHTML;\r\n        this.nodeTextContentMap = new Map();\r\n        for (const node of element.childNodes) {\r\n            if (node.nodeType !== Node.TEXT_NODE) {\r\n                continue;\r\n            }\r\n            this.nodeTextContentMap.set(node, node.textContent);\r\n        }\r\n\r\n        this.parentElement = null;\r\n        this.children = new Array(element.children.length);\r\n        for(let i = 0; i < element.children.length; i++) {\r\n            this.children[i] = new EUVElement(element.children[i]);\r\n        }\r\n    }\r\n\r\n    getNodeTextContent(node) {\r\n        return this.nodeTextContentMap.get(node);\r\n    }\r\n}\r\n\r\nclass EUV {\r\n\r\n    constructor(\r\n        {\r\n            elementSelector,\r\n            mounted = () => {},\r\n            data = {},\r\n            computed = {},\r\n            methods = {},\r\n            directives = {}\r\n        } = {}\r\n    ) {\r\n        if (typeof mounted === \"function\") {\r\n            this.mounted = mounted;\r\n        } else {\r\n            throw new Error(\"mounted must be a function\");\r\n        }\r\n        const that = this;\r\n        this.init = false;\r\n        this.$refs = {};\r\n        this.data = {...data};\r\n        this.computed = computed;\r\n        this.methods = {};\r\n        // 没得 e-\r\n        this.directiveMap = new Map();\r\n        for (let k in directives) {\r\n            if (directives[k].mounted && typeof directives[k].mounted !== \"function\") {\r\n                throw new Error(`directives[${k}].mounted is not a function`);\r\n            }\r\n            this.directiveMap.set(k, directives[k]);\r\n        }\r\n        this.directive(\r\n            \"show\",\r\n            {\r\n                updated(element, attributeValue, euvElement) {\r\n                    const result = that.runExpressionCode(euvElement, attributeValue);\r\n                    if (result) {\r\n                        element.style.display = euvElement.tempDisplay ? euvElement.tempDisplay : \"block\";\r\n                    } else {\r\n                        element.style.display = \"none\";\r\n                    }\r\n                }\r\n            }\r\n        )\r\n\r\n        this.dataElementMapping = new Map();\r\n        const dataElementMapping = this.dataElementMapping;\r\n        for(const k in data) {\r\n            dataElementMapping[k] = new Set();\r\n            Object.defineProperty(this.data, k, {\r\n                get() {\r\n                    if (\r\n                        window.maybeChangeElement &&\r\n                        window.maybeChangeElement instanceof EUVElement\r\n                    ) {\r\n                        // for(const set of dataElementMapping) {\r\n                        //     if (set.has(window.maybeChangeElement.parentElement)) {\r\n                        //         window.maybeChangeElement = null;\r\n                        //         return data[k];\r\n                        //     }\r\n                        // }\r\n                        // console.log(\"maybe change element\", window.maybeChangeElement);\r\n                        dataElementMapping[k].add(window.maybeChangeElement);\r\n                        window.maybeChangeElement = null;\r\n                        // console.log(\"data elements mapping:\", dataElementMapping);\r\n                    }\r\n                    return data[k];\r\n                },\r\n                set(v) {\r\n                    const oldValue = data[k];\r\n                    if (oldValue === v) {\r\n                        return;\r\n                    }\r\n                    data[k] = v;\r\n                    console.log(`[${k}]set`, oldValue, \"=>\", v);\r\n                    for (const el of dataElementMapping[k]) {\r\n                        console.log(\"重新渲染\", el);\r\n                        that.renderEUVElement(el);\r\n                    }\r\n                    // console.log(dataElementMapping);\r\n                }\r\n            });\r\n        }\r\n        for(const k in methods) {\r\n            Object.defineProperty(this.methods, k, {\r\n                get() {\r\n                    return methods[k];\r\n                },\r\n                set(v) {\r\n                    if (typeof v !== \"function\") {\r\n                        throw new Error(\"method must be a function\");\r\n                    }\r\n                    methods[k] = v;\r\n                }\r\n            });\r\n        }\r\n        if (elementSelector) {\r\n            this.mount(elementSelector);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 挂载 EUV APP\r\n     * @param {*} elementSelector\r\n     * @returns\r\n     */\r\n    mount(elementSelector) {\r\n        if (!elementSelector || typeof elementSelector !== \"string\") {\r\n            return;\r\n        }\r\n        /**\r\n         * @type { HTMLElement }\r\n         */\r\n        this.mountedElement = document.querySelector(elementSelector);\r\n        this.mountedElement.setAttribute(\"data-e-app\", \"\");\r\n\r\n        // 初始化元素\r\n        const euvElement = new EUVElement(this.mountedElement);\r\n        const initEUVElement = (parentElement) => {\r\n            for (const e of parentElement.children) {\r\n                e.parentElement = parentElement;\r\n                initEUVElement(e);\r\n            }\r\n        };\r\n        initEUVElement(euvElement);\r\n\r\n        // 渲染DOM元素\r\n        const renderDOMElement = (euvElement) => {\r\n            for (const e of euvElement.children) {\r\n                this.renderEUVElement(e);\r\n                renderDOMElement(e);\r\n            }\r\n        };\r\n        renderDOMElement(euvElement);\r\n\r\n        this.init = true;\r\n        // 初始化 domElement 事件\r\n        const initDOMElementEvent = (euvElement) => {\r\n            for (const eE of euvElement.children) {\r\n                const domElement = eE.domElement;\r\n                for (const [eventName, methodName] of eE.eventMethodMapping) {\r\n                    domElement.addEventListener(eventName, (e) => {\r\n                        this.methods[methodName].bind(this)(e);\r\n                    });\r\n                    domElement.removeAttribute(\"@\" + eventName);\r\n                }\r\n                eE.eventInit = true;\r\n                initDOMElementEvent(eE);\r\n            }\r\n        };\r\n        initDOMElementEvent(euvElement);\r\n        // 初始化 domElement ref\r\n        const initDOMRef = (euvElement) => {\r\n            for (const eE of euvElement.children) {\r\n                const domElement = eE.domElement;\r\n                const refName = domElement.getAttribute(\"ref\");\r\n                if (refName) {\r\n                    this.$refs[refName] = new Proxy(domElement, {\r\n                        get: (target, prop) => {\r\n                            return target[prop];\r\n                        },\r\n                        set: (target, prop, value) => {\r\n                            target[prop] = value;\r\n                            // 判断是否更新某属性\r\n                            const attributeValue = target.getAttribute(prop);\r\n                            if (attributeValue !== undefined && attributeValue !== null) {\r\n                                // 更新属性是否 e-model\r\n                                const attributeName = \"e-model:\" + prop;\r\n                                const bindingValueName = target.getAttribute(attributeName);\r\n                                // 是则更新绑定值\r\n                                if (\r\n                                    this.data[bindingValueName] !== undefined &&\r\n                                    this.data[bindingValueName] !== null\r\n                                ) {\r\n                                    this.data[bindingValueName] = value;\r\n                                }\r\n                            }\r\n                            return true;\r\n                        }\r\n                    });\r\n                    domElement.removeAttribute(\"ref\");\r\n                }\r\n                initDOMRef(eE);\r\n            }\r\n        }\r\n        initDOMRef(euvElement);\r\n\r\n        // 初始化指令，完成指令 mounted 动作\r\n        const initDirective = (euvElement) => {\r\n            for (const eE of euvElement.children) {\r\n                const domElement = eE.domElement;\r\n                for (const [name, directive] of this.directiveMap) {\r\n                    const attributeValue = domElement.getAttribute(`e-${name}`);\r\n                    if (attributeValue && directive.mounted) {\r\n                        directive.mounted(domElement, attributeValue, eE);\r\n                    }\r\n                }\r\n                initDirective(eE);\r\n            }\r\n        }\r\n        initDirective(euvElement);\r\n        // 完成 mounted 动作\r\n        if (this.mounted)\r\n            this.mounted();\r\n    }\r\n\r\n\r\n    /**\r\n     * 指令\r\n     */\r\n    directive(\r\n        name,\r\n        {\r\n            mounted = (el, attributeValue) => {},\r\n            unmount = (el) => {},\r\n            updated = (el, attributeValue, euvElement) => {}\r\n        }\r\n    ) {\r\n        if (typeof mounted !== \"function\") {\r\n            throw new Error(\"mounted must be a function\");\r\n        }\r\n        if (typeof unmount !== \"function\") {\r\n            throw new Error(\"unmount must be a function\");\r\n        }\r\n        if (typeof updated !== \"function\") {\r\n            throw new Error(\"updated must be a function\");\r\n        }\r\n        const d = {\r\n            mounted,\r\n            unmount,\r\n            updated\r\n        };\r\n        this.directiveMap.set(name, d);\r\n    }\r\n\r\n\r\n    // 运行表达式\r\n    runExpressionCode(euvElement, 表达式) {\r\n        window.maybeChangeElement = euvElement;\r\n        // console.log(euvElement, \"run:\", 表达式);\r\n\r\n        // 获取 argNames\r\n        const 获取codeArgNames = (str) => {\r\n            if (!str) {\r\n                return;\r\n            }\r\n            if (str === \"in\" || str === \"of\") {\r\n                return;\r\n            }\r\n\r\n            // 数组或对象\r\n            let splitCache = str.split(\"[\");\r\n            if (splitCache.length === 2) {\r\n                str = splitCache[0];\r\n                const strK = splitCache[1].split(\"]\")[0];\r\n                if (this.data[str]) {\r\n                    const argNames = 获取codeArgNames.bind(this)(strK);\r\n                    // console.log(\"strK:\", strK);\r\n                    // console.log(\"argNames:\", argNames);\r\n                    if (argNames) {\r\n                        return [str, ...argNames];\r\n                    } else {\r\n                        return [str];\r\n                    }\r\n                }\r\n            }\r\n            // 对象\r\n            splitCache = str.split(\".\");\r\n            if (splitCache.length === 2) {\r\n                str = splitCache[0];\r\n                if (this.data[str]) {\r\n                    return [str];\r\n                }\r\n            }\r\n\r\n            if (this.data[str] || this.data[str] !== null) {\r\n                return [str];\r\n            }\r\n            if (this.computed[str]) {\r\n                return [str];\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        let argNames = new Set();\r\n        const args = new Set();\r\n        const keys = 表达式.trim().split(\" \");\r\n        for (const k of keys) {\r\n            const names = 获取codeArgNames(k);\r\n            if (!names) continue;\r\n            for(const n of names) {\r\n                argNames.add(n);\r\n            }\r\n        }\r\n        argNames.forEach((v) => {\r\n            const data = this.data[v] !== undefined\r\n                ? this.data[v]\r\n                : this.computed[v]\r\n                    ? this.computed[v].bind(this)()\r\n                    : undefined;\r\n            args.add(data);\r\n        });\r\n        // console.log(表达式, keys, args);\r\n        argNames = [...argNames].join(\",\");\r\n        const f = new Function(\r\n            argNames,\r\n            `\r\n                return ${表达式};\r\n            `\r\n        );\r\n        window.maybeChangeElement = null;\r\n        return f(...args.values());\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param { EUVElement } euvElement\r\n     * @returns\r\n     */\r\n    renderEUVElement(euvElement) {\r\n        if (!euvElement) {\r\n            return;\r\n        }\r\n        if (!(euvElement instanceof EUVElement)) {\r\n            // throw new Error(\"euvElement must be EUVElement\");\r\n            console.error(\"render element is not EUVElement\", euvElement);\r\n            return;\r\n        }\r\n\r\n        const domElement = euvElement.domElement;\r\n\r\n        /**\r\n         * 替换大括号中的内容\r\n         * @param { Function } dealF 对大括号内容的处理，处理的结果替换原来的值\r\n         */\r\n        const replaceBraceValue = (domElement, dealF) => {\r\n            function* getCodeFromTextContent(textContent) {\r\n                let startIndex, codeEndIndex;\r\n                let text = textContent;\r\n                while((startIndex = text.indexOf(\"{{\")) !== -1) {\r\n                    codeEndIndex = text.indexOf(\"}}\", startIndex);\r\n                    if (codeEndIndex === -1) break;\r\n                    const code = text.substring(startIndex + 2, codeEndIndex).trim();\r\n                    const textEndIndex = codeEndIndex + 2;\r\n                    yield {\r\n                        beforeCode: text.substring(0, startIndex),\r\n                        code,\r\n                    };\r\n                    text = text.substring(textEndIndex);\r\n                    // console.log(text);\r\n                }\r\n            }\r\n\r\n            function dealTextNode(node) {\r\n                const str = node.textContent;\r\n                const gen = getCodeFromTextContent(str);\r\n                let { value, done } = gen.next();\r\n                if (!done) {\r\n                    node.textContent = \"\";\r\n                }\r\n                while(!done && value) {\r\n                    const code = value.code;\r\n                    const result = dealF(code);\r\n                    // console.log(value);\r\n                    node.textContent +=\r\n                        value.beforeCode +\r\n                        result;\r\n                    // console.log(node.textContent);\r\n                    ({ value, done } = gen.next());\r\n                }\r\n            }\r\n\r\n            for (const node of domElement.childNodes) {\r\n                if (node.nodeType !== Node.TEXT_NODE) {\r\n                    continue;\r\n                }\r\n                dealTextNode(node);\r\n            }\r\n        }\r\n\r\n        // 数据双向绑定\r\n        const attributes = euvElement.attributes;\r\n        for (const [name, a] of attributes) {\r\n            // :attribute\r\n            if (name[0] === ':') {\r\n                const result = this.runExpressionCode(euvElement, a);\r\n                const originalAttributeName = name.substring(1);\r\n                domElement.setAttribute(originalAttributeName, result);\r\n            }\r\n            // e-model\r\n            if (name.startsWith(\"e-model\")) {\r\n                const bindingAttribute = name.split(\":\")[1];\r\n                if (!bindingAttribute) {\r\n                    continue;\r\n                }\r\n                if (!this.data[a]) {\r\n                    continue;\r\n                }\r\n                domElement.setAttribute(bindingAttribute, this.data[a]);\r\n                if (domElement[bindingAttribute] !== undefined) {\r\n                    domElement[bindingAttribute] = this.data[a];\r\n                }\r\n                const observerName = `${bindingAttribute}ChangeObserver`;\r\n                if (!domElement[observerName]) {\r\n                    domElement[observerName] = new MutationObserver((records) => {\r\n                        for (const r of records) {\r\n                            if (r.attributeName !== bindingAttribute) {\r\n                                continue;\r\n                            }\r\n                            const newValue = r.target.getAttribute(r.attributeName);\r\n                            if (this.data[a] !== undefined && this.data[a] !== null) {\r\n                                console.log(r);\r\n                                this.data[a] = newValue;\r\n                            }\r\n                        }\r\n                    });\r\n                    domElement[observerName].observe(domElement, {\r\n                        attributes: true,\r\n                    });\r\n                    const 修改属性值 = () => {\r\n                        domElement.setAttribute(bindingAttribute, domElement.value);\r\n                    };\r\n                    domElement.onchange = 修改属性值;\r\n                    domElement.oninput = 修改属性值;\r\n                    this.dataElementMapping[a].add(euvElement);\r\n                }\r\n            }\r\n        }\r\n\r\n        // {{}}\r\n        // 还原 textNode 的内容\r\n        for (const node of domElement.childNodes) {\r\n            if (node.nodeType !== Node.TEXT_NODE) {\r\n                continue;\r\n            }\r\n            const textContent = euvElement.getNodeTextContent(node);\r\n            if (textContent) {\r\n                node.textContent = textContent;\r\n            }\r\n        }\r\n        replaceBraceValue(domElement, (code) => {\r\n            return this.runExpressionCode(euvElement, code);\r\n        });\r\n\r\n\r\n        // 指令 updated\r\n        for (const k of this.directiveMap.keys()) {\r\n            const attributeName = \"e-\" + k;\r\n            const attributeValue = domElement.getAttribute(attributeName);\r\n            if (!attributeValue) {\r\n                continue;\r\n            }\r\n            const directive = this.directiveMap.get(k);\r\n            if (directive.updated) {\r\n                directive.updated(domElement, attributeValue, euvElement);\r\n            }\r\n        }\r\n\r\n        euvElement.domElement = domElement;\r\n        return euvElement.domElement;\r\n    }\r\n}\r\n\r\n\n\n//# sourceURL=webpack://EUV/./src/euv.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createAPP: () => (/* binding */ createAPP)\n/* harmony export */ });\n/* harmony import */ var _euv__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./euv */ \"./src/euv.js\");\n\r\n\r\n/**\r\n *\r\n * @param {{\r\n *     elementSelector: any;\r\n *     mounted?: (() => void) | undefined;\r\n *     data?: {} | undefined;\r\n *     computed?: {} | undefined;\r\n *     methods?: {} | undefined;\r\n *     directives?: {} | undefined;\r\n *   }}\r\n * option\r\n * @returns { EUV }\r\n */\r\nfunction createAPP(option) {\r\n    return new _euv__WEBPACK_IMPORTED_MODULE_0__.EUV(option);\r\n}\r\n\n\n//# sourceURL=webpack://EUV/./src/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});